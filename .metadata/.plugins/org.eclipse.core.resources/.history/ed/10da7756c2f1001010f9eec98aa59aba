/*
 * ui.c - 컴파일 에러 수정 및 최적화 통합본
 */

#include "ui.h"
#include "main.h"
#include "ILI9341_STM32_Driver.h"
#include "ILI9341_GFX.h"
#include <string.h>
#include <stdio.h>
#include <math.h>

// --- 전역 제어 변수 ---
TaskHandle_t lcdTaskHandle = NULL;
QueueHandle_t lcdQueueHandle = NULL;
LcdState_t currentLcdState = LCD_STATE_INIT;

// --- 샘플 데이터 및 UI 상태 ---
uint8_t sin_samples[1024];
uint8_t adsr_samples[1024];

// 헤더파일에 정의된 타입 이름에 맞춰 수정 (예: UI_Wave_t)
volatile uint8_t selected_wave_type = 0; // 0:SINE, 1:SQ, 2:TRI
const char* wave_names[] = {"SINE", "SQUARE", "TRIANGLE"};

// 선택 인덱스 (0~3:ADSR, 4:WAVE, 5:RESO, 6:CUTOFF, 7:VOL)
volatile uint8_t selected_adsr_idx = 0;
volatile uint8_t volume_val = 80;
volatile uint8_t g_ui_oct = 4;

// --- Dirty Flags ---
volatile uint8_t g_ui_dirty = 1;        // 전체 화면 다시 그리기
volatile uint8_t g_ui_adsr_dirty = 1;   // ADSR 그래프 갱신
volatile uint8_t g_ui_text_dirty = 1;   // 텍스트 영역 갱신

// --- 레이아웃 상수 ---
#define ADSR_X0 10
#define ADSR_Y0 40
#define ADSR_X1 230
#define ADSR_Y1 110
#define WAVE_X0 10
#define WAVE_Y0 240
#define WAVE_X1 230
#define WAVE_Y1 300

// --- 내부 함수 선언 ---
static void LCD_Task(void *argument);
static void Generate_Sine_Samples(void);
static void Generate_ADSR_Samples(void);
static void draw_adsr_graph(void);
static void draw_wave_graph(void);
static void draw_ui_elements(void);
static void draw_main_dashboard(void);

// --- 초기화 ---
void UI_Init(void) {
    Generate_Sine_Samples();
    Generate_ADSR_Samples();

    HAL_GPIO_WritePin(GPIOD, RESET_Pin, GPIO_PIN_RESET);
    HAL_Delay(100);
    HAL_GPIO_WritePin(GPIOD, RESET_Pin, GPIO_PIN_SET);
    HAL_Delay(100);

    ILI9341_Init();
    ILI9341_Fill_Screen(BLACK);

    lcdQueueHandle = xQueueCreate(10, sizeof(uint32_t));
    if(lcdQueueHandle == NULL) Error_Handler();

    xTaskCreate(LCD_Task, "LCDTask", 2048, NULL, tskIDLE_PRIORITY + 2, &lcdTaskHandle);
}

// --- 메인 태스크 ---
static void LCD_Task(void *argument) {
    uint32_t received;
    LcdState_t lastState = LCD_STATE_INIT;

    for (;;) {
        // 큐 수신 (10ms 대기)
        if (xQueueReceive(lcdQueueHandle, &received, pdMS_TO_TICKS(10)) == pdTRUE) {
            currentLcdState = (LcdState_t)received;
        }

        if (currentLcdState == LCD_STATE_MAIN_DASH) {
            if (lastState != LCD_STATE_MAIN_DASH) {
                draw_main_dashboard();
            }
        }
        else if (currentLcdState == LCD_STATE_ADSR_VIEW) { // 에러 수정: GRAPH_VIEW -> ADSR_VIEW
            if (lastState != LCD_STATE_ADSR_VIEW || g_ui_dirty) {
                ILI9341_Fill_Screen(BLACK);
                ILI9341_Draw_Filled_Rectangle_Coord(0, 0, 240, 30, CYAN);
                ILI9341_Draw_Text("SYNTH PANEL", 55, 8, BLACK, 2, CYAN);
                ILI9341_Draw_Rectangle(ADSR_X0, ADSR_Y0, 220, 70, WHITE);
                ILI9341_Draw_Rectangle(WAVE_X0, WAVE_Y0, 220, 60, WHITE);
                g_ui_dirty = 0;
                g_ui_adsr_dirty = 1; g_ui_text_dirty = 1;
            }

            if (g_ui_adsr_dirty) {
                g_ui_adsr_dirty = 0;
                ILI9341_Draw_Filled_Rectangle_Coord(ADSR_X0+1, ADSR_Y0+1, ADSR_X1-1, ADSR_Y1-1, BLACK);
                draw_adsr_graph();
            }

            // 파형 그래프는 주기적으로 갱신 (애니메이션 효과를 원한다면 1로 유지)
            ILI9341_Draw_Filled_Rectangle_Coord(WAVE_X0+1, WAVE_Y0+1, WAVE_X1-1, WAVE_Y1-1, BLACK);
            draw_wave_graph();

            if (g_ui_text_dirty) {
                g_ui_text_dirty = 0;
                draw_ui_elements();
            }
        }
        lastState = currentLcdState;
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}

// --- 그래픽 구현부 ---
static void draw_main_dashboard(void) {
    ILI9341_Fill_Screen(BLACK);
    ILI9341_Draw_Filled_Rectangle_Coord(0, 0, 240, 30, GREEN);
    ILI9341_Draw_Text("SYSTEM READY", 48, 10, BLACK, 2, GREEN);
    ILI9341_Draw_Text("Welcome to", 60, 60, WHITE, 2, BLACK);
    ILI9341_Draw_Text("SYNTH RTOS", 30, 90, YELLOW, 3, BLACK);
}

static void draw_ui_elements(void) {
    ILI9341_Draw_Filled_Rectangle_Coord(0, 130, 240, 155, BLACK);
    uint16_t ty = 135;
    ILI9341_Draw_Text("A", 30, ty, (selected_adsr_idx == 0 ? RED : WHITE), 2, BLACK);
    ILI9341_Draw_Text("D", 85, ty, (selected_adsr_idx == 1 ? RED : WHITE), 2, BLACK);
    ILI9341_Draw_Text("S", 140, ty, (selected_adsr_idx == 2 ? RED : WHITE), 2, BLACK);
    ILI9341_Draw_Text("R", 195, ty, (selected_adsr_idx == 3 ? RED : WHITE), 2, BLACK);

    // 파형 바
    uint16_t wave_bg = (selected_adsr_idx == 4 ? RED : DARKGREY);
    ILI9341_Draw_Filled_Rectangle_Coord(0, 165, 240, 190, wave_bg);
    ILI9341_Draw_Text(wave_names[selected_wave_type], 10, 170, WHITE, 2, wave_bg);

    // 볼륨 영역
    ILI9341_Draw_Filled_Rectangle_Coord(0, 210, 240, 235, BLACK);
    uint16_t vol_color = (selected_adsr_idx == 7 ? RED : WHITE);
    ILI9341_Draw_Text("Vol", 10, 215, vol_color, 1, BLACK);
    int vol_w = (180 * volume_val) / 100;
    ILI9341_Draw_Rectangle(45, 215, 180, 8, WHITE);
    ILI9341_Draw_Filled_Rectangle_Coord(46, 216, 46 + vol_w, 222, vol_color);
}

static void draw_adsr_graph(void) {
    for (int x = 0; x < 218; x++) {
        uint32_t idx = (x * 1024) / 218;
        int y = ADSR_Y1 - 5 - ((adsr_samples[idx] * 50) / 255);
        ILI9341_Draw_Pixel(ADSR_X0 + 1 + x, y, YELLOW);
    }
}

static void draw_wave_graph(void) {
    static uint32_t offset = 0;
    offset += 20; // 파형이 흐르는 효과
    for (int x = 0; x < 218; x++) {
        uint32_t idx = ((x * 1024) / 218 + offset) % 1024;
        int y = WAVE_Y1 - 30 + ((sin_samples[idx] - 127) * 25 / 127);
        ILI9341_Draw_Pixel(WAVE_X0 + 1 + x, y, RED);
    }
}

// --- 유틸리티 및 샘플 생성 ---
static void Generate_Sine_Samples(void) {
    for (int i = 0; i < 1024; i++) {
        sin_samples[i] = (uint8_t)(127 + 100 * sin(2.0 * M_PI * i / 1024.0 * 3.0));
    }
}

static void Generate_ADSR_Samples(void) {
    for (int i = 0; i < 1024; i++) {
        if (i < 200) adsr_samples[i] = (i * 255) / 200;
        else if (i < 400) adsr_samples[i] = 255 - ((i-200) * 100) / 200;
        else if (i < 800) adsr_samples[i] = 155;
        else adsr_samples[i] = 155 - ((i-800) * 155) / 224;
    }
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_PIN) {
    static uint32_t last_tick = 0;
    if (HAL_GetTick() - last_tick < 200) return;
    last_tick = HAL_GetTick();

    if (GPIO_PIN == USER_Btn_Pin) {
        if (currentLcdState == LCD_STATE_MAIN_DASH) currentLcdState = LCD_STATE_ADSR_VIEW;
        else currentLcdState = LCD_STATE_MAIN_DASH;

        uint32_t msg = (uint32_t)currentLcdState;
        xQueueSendFromISR(lcdQueueHandle, &msg, NULL);
    }
}
