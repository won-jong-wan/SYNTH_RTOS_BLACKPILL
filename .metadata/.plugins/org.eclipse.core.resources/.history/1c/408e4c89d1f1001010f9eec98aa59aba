/*
 * ui.c - 수정본 (유령 출력 및 잔상 제거)
 */

#include "ui.h"
#include "main.h"
#include "ILI9341_STM32_Driver.h"
#include "ILI9341_GFX.h"
#include <string.h>
#include <stdio.h>
#include <math.h>

TaskHandle_t lcdTaskHandle = NULL;
QueueHandle_t lcdQueueHandle = NULL;

LcdState_t currentLcdState = LCD_STATE_INIT; // 화면 초기 상태

// 모든 플래그 0으로 초기화
volatile UI_DirtyFlags_t g_ui_dirty = {0};

// 버튼 누를 때마다 증가: 0(A) → 1(D) → 2(S) → 3(R) → 4(파형) → 5(RESO) → 6(CUTOFF) → 7(Vol)
volatile uint8_t selected_adsr_idx = 0;

volatile uint8_t volume_val = 0;	// 볼륨 초기 값
volatile uint8_t selected_wave_type = 0; // 0:SINE, 1:SQUARE, 2:TRIANGLE -> 파형의 종류
const char* wave_names[] = {"SINE", "SQUARE", "TRIANGLE"};

// 음계 구조체를 2옥타브 도(C2)로 초기화
volatile NoteInfo_t current_note = {0, 2};

// 샘플 배열 선언
uint8_t adsr_samples[1024];	// ADSR 그래프 배열
uint8_t sin_samples[1024];	// SIN 파형 배열

// 각각 사용할 좌표를 미리 정의
#define TITLE_Y0    0
#define TITLE_Y1    30

#define ADSR_Y0     50
#define ADSR_Y1     110

#define ADSR_LABEL_Y    135

#define WAVE_TITLE_Y0   160
#define WAVE_TITLE_Y1   185

#define FILTER_Y        195

#define VOL_Y           220

#define WAVE_GRAPH_Y0   240
#define WAVE_GRAPH_Y1   295

static void LCD_Task(void *argument);
static void Generate_ADSR_Samples(void);
static void Generate_Sine_Samples(void);
static void draw_main_dashboard(void);
static void draw_title_bar(void);
static void draw_adsr_graph(void);
static void draw_adsr_labels(void);
static void draw_wave_title(void);
static void draw_wave_graph(void);
static void draw_filter_labels(void);
static void draw_volume_bar(void);
static void draw_note_display(void);

void UI_Init(void) {
    // 1. 데이터 생성
    Generate_ADSR_Samples();
    Generate_Sine_Samples();

    // 2. 하드웨어 리셋 및 초기화
    HAL_GPIO_WritePin(GPIOD, RESET_Pin, GPIO_PIN_RESET);
    HAL_Delay(100);
    HAL_GPIO_WritePin(GPIOD, RESET_Pin, GPIO_PIN_SET);
    HAL_Delay(100);

    ILI9341_Init();
    ILI9341_Fill_Screen(BLACK);

    // 3. 큐 생성 및 초기화
    lcdQueueHandle = xQueueCreate(5, sizeof(uint32_t));
    if(lcdQueueHandle == NULL) {
        Error_Handler();
    }

    xQueueReset(lcdQueueHandle); // 부팅 시 쌓인 노이즈 제거

    // 4. 초기 상태 설정
    // 이 값이 MAIN_DASH여야 EXTI 콜백의 첫 번째 if문이 동작합니다.
    currentLcdState = LCD_STATE_MAIN_DASH;
    selected_adsr_idx = 0;

    // 5. Task 생성
    BaseType_t result = xTaskCreate(
        LCD_Task,
        "LCDTask",
        2048,
        NULL,
        tskIDLE_PRIORITY + 2,
        &lcdTaskHandle
    );

    if(result != pdPASS) {
        Error_Handler();
    }
}

// SIN 파형 생성 부분
// 1024개의 값을 만들어서 점 생성
// 5번 물결치는 SIN 파형 생성
static void Generate_Sine_Samples(void) {
    for (int i = 0; i < 1024; i++) {
        sin_samples[i] = (uint8_t)(127 + 100 * sin(2.0 * M_PI * i / 1024.0 * 5.0));
    }
}

// ADSR 그래프 생성 부분
static void Generate_ADSR_Samples(void) {
	// 값 직접 임의로 설정해서 출력
	uint16_t attack_len  = 100; // 작을수록 급격히 상승 (0~1024)
	uint16_t decay_len   = 200; // 피크에서 유지 레벨까지 내려오는 시간
	uint16_t sustain_len = 400; // 유지되는 시간
	uint16_t release_len = 324; // 건반을 뗐을 때 사라지는 시간 (총합 1024 권장)

	uint8_t peak_level    = 240; // Attack의 정점 높이 (0~255)
	uint8_t sustain_level = 120; // Sustain 구간의 높이 (0~peak_level)
	uint8_t base_level    = 30;  // 바닥 높이
    uint16_t idx = 0;

    // ADSR 값 계산
    for (int i = 0; i < attack_len && idx < 1024; i++, idx++) adsr_samples[idx] = base_level + (peak_level - base_level) * i / attack_len;
    for (int i = 0; i < decay_len && idx < 1024; i++, idx++) adsr_samples[idx] = peak_level - (peak_level - sustain_level) * i / decay_len;
    for (int i = 0; i < sustain_len && idx < 1024; i++, idx++) adsr_samples[idx] = sustain_level;
    for (int i = 0; i < release_len && idx < 1024; i++, idx++) adsr_samples[idx] = sustain_level - (sustain_level - base_level) * i / release_len;
    while(idx < 1024) adsr_samples[idx++] = base_level;
}


// 첫 화면 문구
static void draw_main_dashboard(void) {
    ILI9341_Fill_Screen(BLACK);
    vTaskDelay(pdMS_TO_TICKS(10));

    ILI9341_Draw_Filled_Rectangle_Coord(0, 0, 240, 30, GREEN);
    ILI9341_Draw_Text("SYSTEM READY", 48, 10, BLACK, 2, GREEN);

    ILI9341_Draw_Text("Welcome to", 60, 60, WHITE, 2, BLACK);

    ILI9341_Draw_Text("SYNTH RTOS", 30, 90, YELLOW, 3, BLACK);
    ILI9341_Draw_Text("BLACKPILL", 39, 130, CYAN, 3, BLACK);

    ILI9341_Draw_Horizontal_Line(20, 180, 200, WHITE);
    ILI9341_Draw_Text("Press Button", 84, 195, LIGHTGREY, 1, BLACK);
}

static void draw_title_bar(void) {
    ILI9341_Draw_Filled_Rectangle_Coord(0, TITLE_Y0, 240, TITLE_Y1, CYAN);
    ILI9341_Draw_Text("ADSR ENVELOPE", 42, 8, BLACK, 2, CYAN);
    ILI9341_Draw_Horizontal_Line(0, TITLE_Y1, 240, WHITE);
}

static void draw_adsr_graph(void) {
    // 그래프 영역만 지우기
    ILI9341_Draw_Filled_Rectangle_Coord(0, ADSR_Y0, 240, ADSR_Y1, BLACK);

    // ADSR 그래프 그리기
    for(int x = 0; x < 240; x++) {
        uint32_t index = (x * 1024) / 240;
        int16_t y_raw = ADSR_Y1 - ((adsr_samples[index] * (ADSR_Y1 - ADSR_Y0)) / 255);
        if (y_raw < ADSR_Y0) y_raw = ADSR_Y0;
        if (y_raw > ADSR_Y1) y_raw = ADSR_Y1;
        ILI9341_Draw_Pixel(x, (uint16_t)y_raw, YELLOW);
    }
}

static void draw_adsr_labels(void) {
    // 라벨 영역만 지우기
    ILI9341_Draw_Filled_Rectangle_Coord(0, ADSR_LABEL_Y, 240, ADSR_LABEL_Y + 20, BLACK);

    // 라벨 색상 결정
    uint16_t color_A = (selected_adsr_idx == 0) ? RED : WHITE;
    uint16_t color_D = (selected_adsr_idx == 1) ? RED : WHITE;
    uint16_t color_S = (selected_adsr_idx == 2) ? RED : WHITE;
    uint16_t color_R = (selected_adsr_idx == 3) ? RED : WHITE;

    // 배경은 BLACK으로 설정해서 깜빡임 방지
    ILI9341_Draw_Text("A", 30, ADSR_LABEL_Y, color_A, 2, BLACK);
    ILI9341_Draw_Text("D", 85, ADSR_LABEL_Y, color_D, 2, BLACK);
    ILI9341_Draw_Text("S", 140, ADSR_LABEL_Y, color_S, 2, BLACK);
    ILI9341_Draw_Text("R", 195, ADSR_LABEL_Y, color_R, 2, BLACK);
}

static void draw_wave_title(void) {
    uint16_t bar_color = (selected_adsr_idx == 4) ? RED : MAGENTA;

    // 타이틀 바 영역만 지우고 다시 그리기
    ILI9341_Draw_Filled_Rectangle_Coord(0, WAVE_TITLE_Y0, 240, WAVE_TITLE_Y1, bar_color);

    // 파형 이름
    ILI9341_Draw_Text(wave_names[selected_wave_type], 5, 165, WHITE, 2, bar_color);

    // 음계 표시
    draw_note_display();
}

static void draw_note_display(void) {
    const char *notes_list[] = {"C", "D", "E", "F", "G", "A", "B"};
    char note_buf[12];

    uint16_t bar_color = (selected_adsr_idx == 4) ? RED : MAGENTA;

    // 음계 표시
    sprintf(note_buf, "NOTE:%s%d", notes_list[current_note.note_idx], current_note.octave);
    ILI9341_Draw_Text(note_buf, 145, 165, YELLOW, 2, bar_color);
}

static void draw_wave_graph(void) {
    // 파형 그래프 영역만 지우기
    ILI9341_Draw_Filled_Rectangle_Coord(0, WAVE_GRAPH_Y0, 240, WAVE_GRAPH_Y1, BLACK);

    for(int x = 0; x < 240; x++) {
        uint32_t index = (x * 1024) / 240;
        uint8_t sample_val = sin_samples[index];
        int16_t y_raw = WAVE_GRAPH_Y1 - ((sample_val * (WAVE_GRAPH_Y1 - WAVE_GRAPH_Y0)) / 255);
        if(y_raw < WAVE_GRAPH_Y0) y_raw = WAVE_GRAPH_Y0;
        if(y_raw > WAVE_GRAPH_Y1) y_raw = WAVE_GRAPH_Y1;
        ILI9341_Draw_Pixel(x, (uint16_t)y_raw, GREEN);
    }
}

static void draw_filter_labels(void) {
    // 필터 라벨 영역만 지우기
    ILI9341_Draw_Filled_Rectangle_Coord(0, FILTER_Y, 240, FILTER_Y + 20, BLACK);

    uint16_t color_reso = (selected_adsr_idx == 5) ? RED : WHITE;
    uint16_t color_cutoff = (selected_adsr_idx == 6) ? RED : WHITE;

    ILI9341_Draw_Text("RESO", 45, FILTER_Y, color_reso, 2, BLACK);
    ILI9341_Draw_Text("CUTOFF", 125, FILTER_Y, color_cutoff, 2, BLACK);
}

static void draw_volume_bar(void) {
    // 볼륨 영역만 지우기
    ILI9341_Draw_Filled_Rectangle_Coord(0, VOL_Y, 240, VOL_Y + 15, BLACK);

    uint16_t vol_color = (selected_adsr_idx == 7) ? RED : WHITE;

    ILI9341_Draw_Text("Vol", 15, VOL_Y, vol_color, 1, BLACK);

    // 막대 게이지
    for(int i = 0; i < 10; i++) {
        uint16_t bar_x = 45 + (i * 17);
        if (i < (volume_val / 10)) {
            ILI9341_Draw_Filled_Rectangle_Coord(bar_x, VOL_Y, bar_x + 13, VOL_Y + 8, vol_color);
        } else {
            ILI9341_Draw_Rectangle(bar_x, VOL_Y, 13, 8, DARKGREY);
        }
    }

    char vol_buf[6];
    sprintf(vol_buf, "%d  ", volume_val);
    ILI9341_Draw_Text(vol_buf, 215, VOL_Y, vol_color, 1, BLACK);
}


static void LCD_Task(void *argument) {
    uint32_t received;
    LcdState_t lastState = LCD_STATE_MAIN_DASH;

    draw_main_dashboard();

    for(;;) {
        if(xQueueReceive(lcdQueueHandle, &received, portMAX_DELAY) == pdTRUE) {
            LcdState_t nextState = (LcdState_t)received;

            if(nextState == LCD_STATE_MAIN_DASH) {
                draw_main_dashboard();
            }
            else if(nextState == LCD_STATE_ADSR_VIEW) {
                // 메인에서 그래프로 전환 시 전체 다시 그리기
                if (lastState == LCD_STATE_MAIN_DASH) {
                    g_ui_dirty.full_redraw = 1;
                }

                // 전체 그리기로 모든 요소를 이미 그렸으므로, 남아있을 수 있는 개별 플래그들을 전부 0으로 초기화
                if (g_ui_dirty.full_redraw) {
                    g_ui_dirty.full_redraw = 0;

                    ILI9341_Fill_Screen(BLACK);

                    draw_title_bar();
                    draw_adsr_graph();
                    draw_adsr_labels();
                    draw_wave_title();
                    draw_wave_graph();
                    draw_filter_labels();
                    draw_volume_bar();

                    // 모든 dirty flag 초기화
                    g_ui_dirty.adsr_graph = 0;
                    g_ui_dirty.adsr_labels = 0;
                    g_ui_dirty.wave_title = 0;
                    g_ui_dirty.wave_graph = 0;
                    g_ui_dirty.filter_labels = 0;
                    g_ui_dirty.volume_bar = 0;
                    g_ui_dirty.note_display = 0;
                }
                // 부분 업데이트
                else {
                    if (g_ui_dirty.adsr_graph) {
                        g_ui_dirty.adsr_graph = 0;
                        draw_adsr_graph();
                    }

                    if (g_ui_dirty.adsr_labels) {
                        g_ui_dirty.adsr_labels = 0;
                        draw_adsr_labels();
                    }

                    if (g_ui_dirty.wave_title || g_ui_dirty.note_display) {
                        g_ui_dirty.wave_title = 0;
                        g_ui_dirty.note_display = 0;
                        draw_wave_title();
                    }

                    if (g_ui_dirty.wave_graph) {
                        g_ui_dirty.wave_graph = 0;
                        draw_wave_graph();
                    }

                    if (g_ui_dirty.filter_labels) {
                        g_ui_dirty.filter_labels = 0;
                        draw_filter_labels();
                    }

                    if (g_ui_dirty.volume_bar) {
                        g_ui_dirty.volume_bar = 0;
                        draw_volume_bar();
                    }
                }
            }

            currentLcdState = nextState;
            lastState = nextState;
        }
    }
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_PIN) {
    static uint32_t last_tick = 0;
    uint32_t now = HAL_GetTick();

    // 디바운싱
    if(GPIO_PIN == USER_Btn_Pin) {
        if (now < 1000) return;
        if(now - last_tick < 250) return;
        last_tick = now;

        // 메인 화면에서 그래프 화면으로 전환할 때
        if (currentLcdState == LCD_STATE_MAIN_DASH) {
            currentLcdState = LCD_STATE_ADSR_VIEW;
            selected_adsr_idx = 0;	// A 부터 시작
            g_ui_dirty.full_redraw = 1; // 전체 다시 그리기
        }
        else if (currentLcdState == LCD_STATE_ADSR_VIEW) {
            uint8_t prev_idx = selected_adsr_idx;

            if (selected_adsr_idx == 4) { // 파형 선택
                selected_wave_type++;
                if (selected_wave_type > 2) {
                    selected_wave_type = 0;
                    selected_adsr_idx = 5;
                    g_ui_dirty.filter_labels = 1; // 필터 라벨만
                }
                g_ui_dirty.wave_title = 1;  // 파형 타이틀만
                g_ui_dirty.wave_graph = 1;  // 파형 그래프만

                // 음계 변경
                current_note.note_idx++;
                if (current_note.note_idx > 6) {
                    current_note.note_idx = 0;
                    current_note.octave = (current_note.octave == 2) ? 3 : 2;
                }
                g_ui_dirty.note_display = 1; // 음계 표시만
            }
            else if (selected_adsr_idx == 7) { // 볼륨
                volume_val += 10;
                if (volume_val > 100) {
                    volume_val = 10;
                    selected_adsr_idx = 0;
                    g_ui_dirty.adsr_labels = 1; // ADSR 라벨만
                }
                g_ui_dirty.volume_bar = 1; // 볼륨 바만
            }
            else {
                selected_adsr_idx++;

                // 어느 영역이 바뀌었는지 확인
                if (prev_idx <= 3 || selected_adsr_idx <= 3) {
                    g_ui_dirty.adsr_labels = 1;
                }
                if (prev_idx == 4 || selected_adsr_idx == 4) {
                    g_ui_dirty.wave_title = 1;
                }
                if ((prev_idx >= 5 && prev_idx <= 6) || (selected_adsr_idx >= 5 && selected_adsr_idx <= 6)) {
                    g_ui_dirty.filter_labels = 1;
                }
                if (prev_idx == 7 || selected_adsr_idx == 7) {
                    g_ui_dirty.volume_bar = 1;
                }
            }
        }

        uint32_t msg = (uint32_t)currentLcdState;
        BaseType_t xHigherPriorityTaskWoken = pdFALSE;
        xQueueSendFromISR(lcdQueueHandle, &msg, &xHigherPriorityTaskWoken);
        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    }
}
