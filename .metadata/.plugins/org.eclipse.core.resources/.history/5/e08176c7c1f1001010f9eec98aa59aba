/*
 * ui.c - 수정본 (유령 출력 및 잔상 제거)
 */

#include "ui.h"
#include "main.h"
#include "ILI9341_STM32_Driver.h"
#include "ILI9341_GFX.h"
#include <string.h>
#include <stdio.h>
#include <math.h>

TaskHandle_t lcdTaskHandle = NULL;
QueueHandle_t lcdQueueHandle = NULL;

LcdState_t currentLcdState = LCD_STATE_INIT; // 화면 초기 상태

// 버튼 누를 때마다 증가: 0(A) → 1(D) → 2(S) → 3(R) → 4(파형) → 5(RESO) → 6(CUTOFF) → 7(Vol)
uint8_t selected_adsr_idx = 0;

volatile uint8_t volume_val = 0;	// 볼륨 초기 값
volatile uint8_t selected_wave_type = 0; // 0:SINE, 1:SQUARE, 2:TRIANGLE -> 파형의 종류
const char* wave_names[] = {"SINE", "SQUARE", "TRIANGLE"};

// 샘플 배열 선언
uint8_t adsr_samples[1024];	// ADSR 그래프 배열
uint8_t sin_samples[1024];	// SIN 파형 배열.

// 선택 인덱스 (0:A, 1:D, 2:S, 3:R, 4:WAVE, 5:RESO, 6:CUTOFF, 7:VOL)
volatile uint8_t selected_idx = 0;
volatile uint8_t g_ui_vol = 80;
volatile uint8_t g_ui_note = 0;
volatile uint8_t g_ui_oct = 4;

volatile uint8_t g_ui_dirty = 1;        // 전체 화면 다시 그리기
volatile uint8_t g_ui_adsr_dirty = 1;   // ADSR 그래프 곡선 갱신
volatile uint8_t g_ui_wave_dirty = 1;   // 파형 그래프 갱신
volatile uint8_t g_ui_text_dirty = 1;   // 텍스트 라벨 및 하이라이트 갱신

#define ADSR_X0 10
#define ADSR_Y0 40
#define ADSR_X1 230
#define ADSR_Y1 110
#define WAVE_X0 10
#define WAVE_Y0 240
#define WAVE_X1 230
#define WAVE_Y1 300


static void LCD_Task(void *argument);	// LCD 출력
static void Generate_ADSR_Samples(void);	// ADSR 그래프 생성
static void Generate_Sine_Samples(void);	// SIN 파형 생성
static void draw_adsr_graph(void);
static void draw_wave_graph(void);
static void draw_ui_elements(void);

void UI_Init(void) {
    // 1. 데이터 생성
    Generate_ADSR_Samples();
    Generate_Sine_Samples();

    // 2. 하드웨어 리셋 및 초기화
    HAL_GPIO_WritePin(GPIOD, RESET_Pin, GPIO_PIN_RESET);
    HAL_Delay(100);
    HAL_GPIO_WritePin(GPIOD, RESET_Pin, GPIO_PIN_SET);
    HAL_Delay(100);

    ILI9341_Init();
    ILI9341_Fill_Screen(BLACK);

    // 3. 큐 생성 및 초기화
    lcdQueueHandle = xQueueCreate(5, sizeof(uint32_t));
    if(lcdQueueHandle == NULL) {
        Error_Handler();
    }

    xQueueReset(lcdQueueHandle); // 부팅 시 쌓인 노이즈 제거

    // 4. 초기 상태 설정
    // 이 값이 MAIN_DASH여야 EXTI 콜백의 첫 번째 if문이 동작합니다.
    currentLcdState = LCD_STATE_MAIN_DASH;
    selected_adsr_idx = 0;

    // 5. Task 생성
    BaseType_t result = xTaskCreate(
        LCD_Task,
        "LCDTask",
        2048,
        NULL,
        tskIDLE_PRIORITY + 2,
        &lcdTaskHandle
    );

    if(result != pdPASS) {
        Error_Handler();
    }
}

// SIN 파형 생성 부분
// 1024개의 값을 만들어서 점 생성
// 5번 물결치는 SIN 파형 생성
static void Generate_Sine_Samples(void) {
    for (int i = 0; i < 1024; i++) {
        sin_samples[i] = (uint8_t)(127 + 100 * sin(2.0 * M_PI * i / 1024.0 * 5.0));
    }
}

// ADSR 그래프 생성 부분
static void LCD_Task(void *argument) {
    uint32_t received;
    LcdState_t lastState = LCD_STATE_INIT;

    for (;;) {
        // 큐 확인 (10ms 타임아웃으로 반응성 확보)
        if (xQueueReceive(lcdQueueHandle, &received, pdMS_TO_TICKS(10)) == pdTRUE) {
            currentLcdState = (LcdState_t)received;
        }

        if (currentLcdState == LCD_STATE_MAIN_DASH) {
            if (lastState != LCD_STATE_MAIN_DASH) {
                ILI9341_Fill_Screen(BLACK);
                ILI9341_Draw_Text("SYSTEM READY", 55, 120, GREEN, 2, BLACK);
            }
        }
        else if (currentLcdState == LCD_STATE_GRAPH_VIEW) {
            // 1. 최초 진입 시 프레임 그리기
            if (lastState != LCD_STATE_GRAPH_VIEW || g_ui_dirty) {
                ILI9341_Fill_Screen(BLACK);
                ILI9341_Draw_Filled_Rectangle_Coord(0, 0, 240, 30, CYAN);
                ILI9341_Draw_Text("SYNTH PANEL", 55, 8, BLACK, 2, CYAN);
                // 고정 프레임
                ILI9341_Draw_Rectangle(ADSR_X0, ADSR_Y0, 220, 70, WHITE);
                ILI9341_Draw_Rectangle(WAVE_X0, WAVE_Y0, 220, 60, WHITE);
                g_ui_dirty = 0;
                g_ui_adsr_dirty = 1; g_ui_wave_dirty = 1; g_ui_text_dirty = 1;
            }

            // 2. ADSR 그래프 업데이트 (내부만 지우고 다시 그리기)
            if (g_ui_adsr_dirty) {
                g_ui_adsr_dirty = 0;
                ILI9341_Draw_Filled_Rectangle_Coord(ADSR_X0+1, ADSR_Y0+1, ADSR_X1-1, ADSR_Y1-1, BLACK);
                draw_adsr_graph();
            }

            // 3. 파형 그래프 업데이트
            if (g_ui_wave_dirty) {
                g_ui_wave_dirty = 0;
                ILI9341_Draw_Filled_Rectangle_Coord(WAVE_X0+1, WAVE_Y0+1, WAVE_X1-1, WAVE_Y1-1, BLACK);
                draw_wave_graph();
            }

            // 4. 텍스트 및 선택 하이라이트 업데이트
            if (g_ui_text_dirty) {
                g_ui_text_dirty = 0;
                draw_ui_elements();
            }
        }
        lastState = currentLcdState;
        vTaskDelay(pdMS_TO_TICKS(16)); // 약 60fps
    }
}

// --- 그래픽 세부 구현 ---

static void draw_ui_elements(void) {
    // ADSR 라벨 영역 소거 및 출력
    ILI9341_Draw_Filled_Rectangle_Coord(0, 130, 240, 155, BLACK);
    uint16_t ty = 135;
    ILI9341_Draw_Text("A", 30, ty, (selected_idx == 0 ? RED : WHITE), 2, BLACK);
    ILI9341_Draw_Text("D", 85, ty, (selected_idx == 1 ? RED : WHITE), 2, BLACK);
    ILI9341_Draw_Text("S", 140, ty, (selected_idx == 2 ? RED : WHITE), 2, BLACK);
    ILI9341_Draw_Text("R", 195, ty, (selected_idx == 3 ? RED : WHITE), 2, BLACK);

    // 파형 및 노트 정보
    ILI9341_Draw_Filled_Rectangle_Coord(0, 165, 240, 190, (selected_idx == 4 ? RED : DARKGREY));
    ILI9341_Draw_Text(wave_names[g_ui_wave], 10, 170, WHITE, 2, (selected_idx == 4 ? RED : DARKGREY));

    char note_buf[10];
    sprintf(note_buf, "NOTE:C%d", g_ui_oct);
    ILI9341_Draw_Text(note_buf, 140, 170, YELLOW, 2, (selected_idx == 4 ? RED : DARKGREY));

    // 볼륨 바
    ILI9341_Draw_Filled_Rectangle_Coord(10, 310, 230, 318, BLACK);
    ILI9341_Draw_Rectangle(10, 310, 220, 8, WHITE);
    int vol_w = (218 * g_ui_vol) / 100;
    ILI9341_Draw_Filled_Rectangle_Coord(11, 311, 11 + vol_w, 317, (selected_idx == 7 ? RED : GREEN));
}

static void draw_adsr_graph(void) {
    // 실제 곡선 그리기 로직 (adsr_samples 기반)
    for (int x = 0; x < 218; x++) {
        uint32_t idx = (x * 1024) / 218;
        int y = ADSR_Y1 - 5 - ((adsr_samples[idx] * 50) / 255);
        ILI9341_Draw_Pixel(ADSR_X0 + 1 + x, y, YELLOW);
    }
}

static void draw_wave_graph(void) {
    for (int x = 0; x < 218; x++) {
        uint32_t idx = (x * 1024) / 218;
        int y = WAVE_Y1 - 30 + ((sin_samples[idx] - 127) * 25 / 127);
        ILI9341_Draw_Pixel(WAVE_X0 + 1 + x, y, RED);
    }
}

// --- 인터럽트 콜백 ---
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_PIN) {
    static uint32_t last_tick = 0;
    if (HAL_GetTick() - last_tick < 200) return;
    last_tick = HAL_GetTick();

    if (GPIO_PIN == USER_Btn_Pin) {
        if (currentLcdState == LCD_STATE_MAIN_DASH) currentLcdState = LCD_STATE_GRAPH_VIEW;
        else currentLcdState = LCD_STATE_MAIN_DASH;

        uint32_t msg = (uint32_t)currentLcdState;
        xQueueSendFromISR(lcdQueueHandle, &msg, NULL);
    }

    // 버튼이나 엔코더 조작 시
    // selected_idx++; 혹은 값 변경 로직 후
    // g_ui_text_dirty = 1; 플래그만 세워주면 Task에서 알아서 그립니다.
}

// --- 샘플 생성 로직 ---
static void Generate_Sine_Samples(void) {
    for (int i = 0; i < 1024; i++) {
        sin_samples[i] = (uint8_t)(127 + 100 * sin(2.0 * M_PI * i / 1024.0 * 3.0));
    }
}

static void Generate_ADSR_Samples(void) {
    // 간단한 ADSR 형상 생성
    for (int i = 0; i < 1024; i++) {
        if (i < 200) adsr_samples[i] = (i * 255) / 200; // A
        else if (i < 400) adsr_samples[i] = 255 - ((i-200) * 100) / 200; // D
        else if (i < 800) adsr_samples[i] = 155; // S
        else adsr_samples[i] = 155 - ((i-800) * 155) / 224; // R
    }
}
