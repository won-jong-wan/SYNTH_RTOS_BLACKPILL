/*
 * ui.c - 수정본 (유령 출력 및 잔상 제거)
 */

#include "ui.h"
#include "main.h"
#include "ILI9341_STM32_Driver.h"
#include "ILI9341_GFX.h"
#include <string.h>
#include <math.h>

TaskHandle_t lcdTaskHandle = NULL;
QueueHandle_t lcdQueueHandle = NULL;

LcdState_t currentLcdState = LCD_STATE_INIT;
uint8_t selected_adsr_idx = 0;

volatile uint8_t selected_wave_type = 0; // 0:SINE, 1:SQUARE, 2:TRIANGLE
const char* wave_names[] = {"SINE WAVE", "SQUARE WAVE", "TRIANGLE WAVE"};

// 샘플 배열 선언
uint8_t adsr_samples[1024];
uint8_t sin_samples[1024];

static void LCD_Task(void *argument);
static void Generate_ADSR_Samples(void);
static void Generate_Sine_Samples(void);
static void draw_main_dashboard(void);
static void draw_dual_graph(uint8_t force_clear);

void UI_Init(void) {
    // 1. 데이터 생성
    Generate_ADSR_Samples();
    Generate_Sine_Samples();

    // 2. 하드웨어 리셋 및 초기화
    HAL_GPIO_WritePin(GPIOD, RESET_Pin, GPIO_PIN_RESET);
    HAL_Delay(100);
    HAL_GPIO_WritePin(GPIOD, RESET_Pin, GPIO_PIN_SET);
    HAL_Delay(100);

    ILI9341_Init();
    ILI9341_Fill_Screen(BLACK);

    // 3. 큐 생성 및 초기화
    lcdQueueHandle = xQueueCreate(5, sizeof(uint32_t));
    if(lcdQueueHandle == NULL) {
        Error_Handler();
    }
    xQueueReset(lcdQueueHandle); // 부팅 시 쌓인 노이즈 제거

    // 4. [매우 중요] 초기 상태 설정
    // 이 값이 MAIN_DASH여야 EXTI 콜백의 첫 번째 if문이 동작합니다.
    currentLcdState = LCD_STATE_MAIN_DASH;
    selected_adsr_idx = 0;

    // 5. Task 생성
    BaseType_t result = xTaskCreate(
        LCD_Task,
        "LCDTask",
        2048,
        NULL,
        tskIDLE_PRIORITY + 2,
        &lcdTaskHandle
    );

    if(result != pdPASS) {
        Error_Handler();
    }
}

static void Generate_Sine_Samples(void) {
    for (int i = 0; i < 1024; i++) {
        sin_samples[i] = (uint8_t)(127 + 100 * sin(2.0 * M_PI * i / 1024.0 * 5.0));
    }
}

static void Generate_ADSR_Samples(void) {
    uint16_t attack_len = 200, decay_len = 150, sustain_len = 500, release_len = 174;
    uint8_t peak_level = 240, sustain_level = 160, base_level = 30;
    uint16_t idx = 0;

    for (int i = 0; i < attack_len && idx < 1024; i++, idx++) adsr_samples[idx] = base_level + (peak_level - base_level) * i / attack_len;
    for (int i = 0; i < decay_len && idx < 1024; i++, idx++) adsr_samples[idx] = peak_level - (peak_level - sustain_level) * i / decay_len;
    for (int i = 0; i < sustain_len && idx < 1024; i++, idx++) adsr_samples[idx] = sustain_level;
    for (int i = 0; i < release_len && idx < 1024; i++, idx++) adsr_samples[idx] = sustain_level - (sustain_level - base_level) * i / release_len;
    while(idx < 1024) adsr_samples[idx++] = base_level;
}

static void draw_main_dashboard(void) {
    ILI9341_Fill_Screen(BLACK);
    vTaskDelay(pdMS_TO_TICKS(10));

    ILI9341_Draw_Filled_Rectangle_Coord(0, 0, 240, 30, GREEN);
    ILI9341_Draw_Text("SYSTEM READY", 55, 10, BLACK, 2, GREEN);

    ILI9341_Draw_Text("Welcome to", 30, 60, WHITE, 2, BLACK);
    ILI9341_Draw_Text("SYNTH RTOS", 20, 90, YELLOW, 3, BLACK);
    ILI9341_Draw_Text("BLACKPILL", 10, 130, CYAN, 3, BLACK);

    ILI9341_Draw_Horizontal_Line(20, 180, 200, WHITE);
    ILI9341_Draw_Text("Press Button", 60, 195, LIGHTGREY, 1, BLACK);
}

static void draw_dual_graph(uint8_t force_clear) {
    // 1. 화면 전체 또는 기본 프레임 초기화
    if (force_clear) {
        ILI9341_Fill_Screen(BLACK);
        vTaskDelay(pdMS_TO_TICKS(5));

        // [상단] ADSR 타이틀 바 및 배경 그래프
        ILI9341_Draw_Filled_Rectangle_Coord(0, 0, 240, 30, CYAN);
        ILI9341_Draw_Text("ADSR ENVELOPE", 40, 8, BLACK, 2, CYAN);

        for(int x = 0; x < 240; x++) {
            uint32_t index = (x * 1024) / 240;
            // ADSR 샘플 데이터를 노란색으로 출력
            int16_t y_raw = 110 - ((adsr_samples[index] * 60) / 255);
            ILI9341_Draw_Pixel(x, (uint16_t)y_raw, YELLOW);
        }

        // [중앙] 구분선
        ILI9341_Draw_Horizontal_Line(0, 155, 240, WHITE);
    }

    // 2. [라벨 업데이트] ADSR 파라미터 (A, D, S, R)
    uint16_t adrs_y = 135;
    ILI9341_Draw_Filled_Rectangle_Coord(0, 130, 240, 153, BLACK); // 텍스트 영역 소거
    ILI9341_Draw_Text("A", 18, adrs_y, (selected_adsr_idx == 0 ? RED : WHITE), 2, BLACK);
    ILI9341_Draw_Text("D", 63, adrs_y, (selected_adsr_idx == 1 ? RED : WHITE), 2, BLACK);
    ILI9341_Draw_Text("S", 135, adrs_y, (selected_adsr_idx == 2 ? RED : WHITE), 2, BLACK);
    ILI9341_Draw_Text("R", 215, adrs_y, (selected_adsr_idx == 3 ? RED : WHITE), 2, BLACK);

    // 3. [라벨 업데이트] 필터 파라미터 (RESO, CUTOFF)
    uint16_t filter_y = 195;
    ILI9341_Draw_Filled_Rectangle_Coord(0, 190, 240, 215, BLACK); // 텍스트 영역 소거
    ILI9341_Draw_Text("RESO", 30, filter_y, (selected_adsr_idx == 4 ? RED : WHITE), 2, BLACK);
    ILI9341_Draw_Text("CUTOFF", 130, filter_y, (selected_adsr_idx == 5 ? RED : WHITE), 2, BLACK);

    // 4. [섹션 업데이트] 파형 타이틀 바 (WAVE TYPE)
    // selected_adsr_idx가 6일 때만 빨간색(선택됨), 평소에는 보라색
    uint16_t wave_bar_color = (selected_adsr_idx == 6 ? RED : MAGENTA);
    ILI9341_Draw_Filled_Rectangle_Coord(0, 160, 240, 185, wave_bar_color);

    // 현재 선택된 파형 이름 출력 (SINE, SQUARE, TRIANGLE 중 하나)
    ILI9341_Draw_Text(wave_names[selected_wave_type], 65, 165, WHITE, 2, wave_bar_color);

    // 5. [하단 그래프] 선택된 파형 실시간 계산 및 출력
    // 파형 모양이 바뀔 수 있으므로 매번 하단 영역(Y: 225~318)을 지우고 다시 그림
    ILI9341_Draw_Filled_Rectangle_Coord(0, 225, 240, 318, BLACK);



    for(int x = 0; x < 240; x++) {
        uint32_t index = (x * 1024) / 240; // 0 ~ 1023 인덱스 변환
        uint8_t sample_val;

        // --- 파형 데이터 계산 (에러 방지용 직접 계산 로직) ---
        if (selected_wave_type == 0) {
            // SINE: 기존 배열 데이터 사용
            sample_val = sin_samples[index];
        }
        else if (selected_wave_type == 1) {
            // SQUARE: 절반은 High(255), 절반은 Low(0)
            sample_val = (index < 512) ? 255 : 0;
        }
        else {
            // TRIANGLE: 삼각 뿔 모양으로 계산
            if (index < 512) {
                sample_val = (uint8_t)(index / 2); // 0 -> 255 상승
            } else {
                sample_val = (uint8_t)(255 - ((index - 512) / 2)); // 255 -> 0 하강
            }
        }

        // 파형을 화면 최하단에 배치 (Y 기준점: 295, 진폭: 50)
        int16_t y_raw = 295 - ((sample_val * 50) / 255);

        // LCD 하단 경계(320)를 넘지 않도록 클리핑
        if(y_raw > 318) y_raw = 318;
        if(y_raw < 220) y_raw = 220;

        ILI9341_Draw_Pixel(x, (uint16_t)y_raw, GREEN);
    }
}

static void LCD_Task(void *argument) {
    uint32_t received;

    // 시작 시 메인 화면 그리기
    draw_main_dashboard();
    LcdState_t lastState = LCD_STATE_MAIN_DASH;

    for(;;) {
        if(xQueueReceive(lcdQueueHandle, &received, portMAX_DELAY) == pdTRUE) {
            LcdState_t nextState = (LcdState_t)received;

            if(nextState == LCD_STATE_MAIN_DASH) {
                draw_main_dashboard();
            }
            else if(nextState == LCD_STATE_ADSR_VIEW) {
                // 이전 상태가 메인이었다면 전체를 새로 그림(force_clear=1)
                uint8_t force_clear = (lastState == LCD_STATE_MAIN_DASH);
                draw_dual_graph(force_clear);
            }

            // [추가] 인터럽트 콜백 함수와 상태를 동기화
            currentLcdState = nextState;
            lastState = nextState;
        }
    }
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_PIN) {
    static uint32_t last_tick = 0;
    uint32_t now = HAL_GetTick();

    if(GPIO_PIN == USER_Btn_Pin) {
        if (now < 1000) return; // 부팅 가드 타임
        if(now - last_tick < 250) return; // 디바운싱
        last_tick = now;

        if (currentLcdState == LCD_STATE_MAIN_DASH) {
            currentLcdState = LCD_STATE_ADSR_VIEW;
            selected_adsr_idx = 0;
        }
        else if (currentLcdState == LCD_STATE_ADSR_VIEW) {
            // [수정 핵심] 인덱스 6(파형 바)일 때의 동작
            if (selected_adsr_idx == 6) {
                selected_wave_type++; // SINE -> SQUARE -> TRI 순으로 변경

                if (selected_wave_type > 2) {
                    // 모든 파형을 다 보여줬다면 다시 A(0)로 돌아감
                    selected_wave_type = 0;
                    selected_adsr_idx = 0;
                }
            } else {
                // 0~5번(ADSR, RESO, CUTOFF)까지는 다음 칸으로 이동
                selected_adsr_idx++;
            }
        }

        uint32_t msg = (uint32_t)currentLcdState;
        BaseType_t xHigherPriorityTaskWoken = pdFALSE;
        xQueueSendFromISR(lcdQueueHandle, &msg, &xHigherPriorityTaskWoken);
        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    }
}
